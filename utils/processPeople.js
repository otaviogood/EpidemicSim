"use strict";

var assert = require("assert");
const fs = require("fs");
var MersenneTwister = require("mersenne-twister");
var rand = new MersenneTwister(1234567890);
var turf = require("@turf/turf");
const papa = require("papaparse");
var stringify = require("json-stable-stringify-without-jsonify");
var flatbuffers = require("flatbuffers").flatbuffers;
var FlatbufPlaces = require("./flatbuffers/households_generated").Flatbuf; // Generated by flatc compiler.
var FlatbufPeople = require("./flatbuffers/people_generated").Flatbuf; // Generated by flatc compiler.

const misc = require("./misc");
const countyInfo = require("./countyUtils");
const mapBounds = require("./mapBounds");

let houseHoldFile = "processedData/" + mapBounds.defaultPlace + "_Households.json";
let officeFile = "processedData/" + mapBounds.defaultPlace + "_Offices.json";
let countyPolygonsFile = "processedData/" + mapBounds.defaultPlace + "_CountyPolygons.json";

// Biased, but not much for small ranges.
function randint(rand, a, b) {
    let temp = rand.random_int31();
    return (temp % (b - a)) + a;
}

// Load lat/lon bounds
let allCountyBounds = JSON.parse(fs.readFileSync("processedData/" + mapBounds.defaultPlace + "_AllCountyBounds.json", "utf8"));
// -1 indexes the bounds for all the counties, not just one.
let latMin = allCountyBounds["-1"]["min"][0];
let latMax = allCountyBounds["-1"]["max"][0];
let lonMin = allCountyBounds["-1"]["min"][1];
let lonMax = allCountyBounds["-1"]["max"][1];
let latAdjust = Math.cos(misc.toRadians((latMin + latMax) * 0.5)); // Adjust for curved earth (approximately with a point)

// Normalizes positions so they are in the [0..1] range on x and y.
// Returns [x, y] tuple.
function latLonToPos(lat, lon) {
    let maxDelta = Math.max(lonMax - lonMin, (latMax - latMin) / latAdjust);
    let xpos = (lon - lonMin) / maxDelta;
    let ypos = (latMax - lat) / maxDelta; // Flip and make it relative to the top since graphics coords are from upper-left
    ypos /= latAdjust; // Adjust for curved earth
    return [xpos, ypos];
}
function latLonDistKm(latA, lonA, latB, lonB) {
    let dx = (lonB - lonA) * latAdjust;
    let dy = latB - latA;
    let dx_km = dx * 111.32;
    let dy_km = dy * 110.574;
    return Math.sqrt(dx_km * dx_km + dy_km * dy_km);
}

function SimplePlaceLatLon(lat, lon, capacity, countyIndex) {
    let sp = new misc.SimplePlace(lat, lon, capacity, countyIndex);
    [sp.xpos, sp.ypos] = latLonToPos(lat, lon);
    return sp;
}

class SimplePerson {
    id = 0;
    lat = 0;
    lon = 0;
    homeIndex = -1;
    officeIndex = -1;
    supermarketIndex = -1;
    hospitalIndex = -1;
    county = -1;
    age = -1;
    maleFemale;
    constructor(id) {
        this.id = id;
    }
}

async function doEverything() {
    let countyStuff = new countyInfo.CountyInfo();
    await countyStuff.readAllCountiesCensus();
    console.log(countyStuff.censusInfo);

    // -------------------- Load Households --------------------
    // let homeDataJSON = JSON.parse(fs.readFileSync("processedData/" + mapBounds.defaultPlace + "_Households.json", "utf8"));
    // let allHouseholds = [];
    // let totalHomeCapacity = 0;
    // for (const p of homeDataJSON) {
    //     // allHouseholds.push(new Place(one.lat(), one.lon(), one.capacity(), one.countyIndex()));
    //     allHouseholds.push(new misc.SimplePlace(p[0], p[1], p[2], p[3]));
    //     totalHomeCapacity += p[2];
    // }

    let hhfb = FlatbufPlaces.PlaceArray.getRootAsPlaceArray(
        misc.loadFlatBuffer("processedData/" + mapBounds.defaultPlace + "_Households.fb")
    );
    let placeLen = hhfb.placeLength();
    let allHouseholds = [];
    for (let i = 0; i < placeLen; i++) {
        let one = hhfb.place(i);
        allHouseholds.push(SimplePlaceLatLon(one.lat(), one.lon(), one.capacity(), one.countyIndex()));
    }
    let totalHomeCapacity = hhfb.totalHomeCapacity();
    console.log(totalHomeCapacity);

    // -------------------- Load Offices --------------------
    let officeDataJSON = JSON.parse(fs.readFileSync(officeFile, "utf8"));
    let allOffices = [];
    let totalOfficeCapacity = 0;
    for (const p of officeDataJSON) {
        allOffices.push(SimplePlaceLatLon(p[0], p[1], p[2], p[3]));
        totalOfficeCapacity += p[2];
    }
    console.log("Total office capacity from file: " + totalOfficeCapacity);
    console.log("Total offices: " + allOffices.length);
    console.log("Average office size: " + totalOfficeCapacity / allOffices.length);

    // Load supermarkets
    let allSuperMarkets = [];
    let supermarketJSON = JSON.parse(fs.readFileSync("processedData/" + mapBounds.defaultPlace + "_Supermarkets.json", "utf8"));
    for (const sm of supermarketJSON) allSuperMarkets.push(SimplePlaceLatLon(sm[0], sm[1], 200, -1)); // TODO: supermarket capacity???

    // Load hospitals
    let allHospitals = [];
    let hospitalsJSON = JSON.parse(fs.readFileSync("processedData/" + mapBounds.defaultPlace + "_Hospitals.json", "utf8"));
    for (const sm of hospitalsJSON) allHospitals.push(SimplePlaceLatLon(sm[0], sm[1], 200, -1)); // TODO: hospital capacity???

    // ------------ done loading ----------------
    let householdIndex = 0;
    let done = false;
    let allPeople = [];
    let totalCommuteDistance = 0.0;
    while (!done) {
        let person = new SimplePerson(allPeople.length);
        // Assign a random household, without overflowing the capacity
        // Since houses are already randomly ordered, just assign houses sequentially. Better for cache.
        let hh = allHouseholds[householdIndex];
        if (hh.residentCount >= hh.capacity) {
            householdIndex++;
            if (householdIndex == allHouseholds.length - 1) done = true;
            hh = allHouseholds[householdIndex];
        }
        //hh.residents.push(allPeople.length);
        hh.residentCount++;
        [person.xpos, person.ypos] = latLonToPos(hh.lat, hh.lon);
        person.homeIndex = householdIndex;
        person.county = hh.countyIndex;

        // Assign a random office
        // let randOff = randint(rand, 0, allOffices.length);
        // let office = allOffices[randOff];
        // // If the office is over capacity, do one extra try to find another office.
        // // This will let offices go over capacity sometimes, but that's probably ok.
        // if (office.residentCount >= office.capacity) {
        //     randOff = randint(rand, 0, allOffices.length);
        //     office = allOffices[randOff];
        // }
        // // office.residents.push(allPeople.length);
        // office.residentCount++;

        let randOffice = randint(rand, 0, allOffices.length);
        let officeDist = Number.MAX_VALUE;
        // Gotta get spatial data structure to work so i can query for nearest things. This is a hacky patchy job for now...
        for (let j = 0; j < allOffices.length / 20000 + 1; j++) {
            let office = allOffices[randOffice];
            let dx = person.xpos - office.xpos;
            let dy = person.ypos - office.ypos;
            let distSq = dx * dx + dy * dy;
            if (distSq < officeDist) {
                officeDist = distSq;
                person.officeIndex = randOffice;
            }
            randOffice = randint(rand, 0, allOffices.length);
        }
        // allOffices[randOffice].residents.push(allPeople.length);
        allOffices[person.officeIndex].residentCount++;


        // person.officeIndex = randOff;
        let officePos = allOffices[person.officeIndex];
        let homePos = allHouseholds[person.homeIndex];
        totalCommuteDistance += latLonDistKm(officePos.lat, officePos.lon, homePos.lat, homePos.lon);

        // Assign a semi-random, but close-to-your-house supermarket as your favorite place to go
        let randMarket = randint(rand, 0, allSuperMarkets.length);
        let marketDist = Number.MAX_VALUE;
        // Gotta get spatial data structure to work so i can query for nearest things. This is a hacky patchy job for now...
        for (let j = 0; j < allSuperMarkets.length / 4 + 1; j++) {
            let market = allSuperMarkets[randMarket];
            let dx = person.xpos - market.xpos;
            let dy = person.ypos - market.ypos;
            let distSq = dx * dx + dy * dy;
            if (distSq < marketDist) {
                marketDist = distSq;
                person.marketIndex = randMarket;
            }
            randMarket = randint(rand, 0, allSuperMarkets.length);
        }
        // allSuperMarkets[randMarket].residents.push(allPeople.length);
        allSuperMarkets[person.marketIndex].residentCount++;

        // Assign a semi-random, but close-to-your-house hospital as your favorite place to go
        let randHospital = randint(rand, 0, allHospitals.length);
        let hospitalDist = Number.MAX_VALUE;
        // Gotta get spatial data structure to work so i can query for nearest things. This is a hacky patchy job for now...
        for (let j = 0; j < allHospitals.length / 8 + 1; j++) {
            let hospital = allHospitals[randHospital];
            assert(hospital.xpos >= 0);
            assert(hospital.xpos <= 1.0);
            assert(person.xpos >= 0);
            assert(person.xpos <= 1.0);
            let dx = person.xpos - hospital.xpos;
            let dy = person.ypos - hospital.ypos;
            let distSq = dx * dx + dy * dy;
            if (distSq < hospitalDist) {
                hospitalDist = distSq;
                person.hospitalIndex = randHospital;
            }
            randHospital = randint(rand, 0, allHospitals.length);
        }

        // ---- Demographics ----
        let pd = new misc.ProbabilityDistribution([countyStuff.fractionMale, 1.0 - countyStuff.fractionMale]);
        person.maleFemale = pd.sampleProbabilites(rand);

        pd = new misc.ProbabilityDistribution([
            countyStuff.fractionAge0_4,
            countyStuff.fractionAge5_9,
            countyStuff.fractionAge10_14,
            countyStuff.fractionAge15_19,
            countyStuff.fractionAge20_24,
            countyStuff.fractionAge25_34,
            countyStuff.fractionAge35_44,
            countyStuff.fractionAge45_54,
            countyStuff.fractionAge55_59,
            countyStuff.fractionAge60_64,
            countyStuff.fractionAge65_74,
            countyStuff.fractionAge75_84,
            countyStuff.fractionAge85_up,
        ]);
        const ranges = [0,5,10,15,20,25,35,45,55,60,65,75,85,100];
        let bucket = pd.sampleProbabilites(rand);
        person.age = misc.randint(rand, ranges[bucket], ranges[bucket+1]);

        allPeople.push(person);
    }
    console.log("total people: " + allPeople.length);
    console.log("used homes: " + householdIndex);
    console.log("Average commute distance: " + (totalCommuteDistance / allPeople.length).toFixed(2) + "km");

    // ---- Build the flatbuffer of people ----
    var builder = new flatbuffers.Builder(allPeople.length);
    let allSimplePeople = [];
    for (let i = 0; i < allPeople.length; i++) {
        let p = allPeople[i];
        let simplePerson = FlatbufPeople.Person.createPerson(
            builder,
            p.homeIndex,
            p.officeIndex,
            p.marketIndex,
            p.hospitalIndex,
            p.county,
            0,
            p.age,
            p.maleFemale,
            0
        );
        allSimplePeople.push(simplePerson);
    }
    let allPeopleOffset = FlatbufPeople.PersonArray.createPeopleVector(builder, allSimplePeople);
    builder.finish(FlatbufPeople.PersonArray.createPersonArray(builder, allPeopleOffset, 31337));
    fs.writeFileSync("processedData/" + mapBounds.defaultPlace + "_FinalPeople.fb", builder.asUint8Array(), { encoding: null });
}

doEverything();
