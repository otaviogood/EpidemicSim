import "@babel/polyfill"; // This is for using ES2017 features, like async/await.
import moment from "moment";
import { Person, PersonTight, PlaceType, numPlaceTypes } from "./person";
import { Spatial, Grid } from "./spatial";
import { CountyStats, GraphType } from "./county-stats";
import * as Params from "./params";
import * as util from "./util";
// https://github.com/boo1ean/mersenne-twister
import MersenneTwister from "mersenne-twister";
import RandomFast from "./random-fast";
import Module from "./generated_wasm/resident_counter";
var moduleInstance: any = null;
// import latlons from "../../contact_tracing/devon_since_feb.json";
// const allLocations = (<any>latlons).locations;
// console.log(allLocations);

var flatbuffers = require("flatbuffers").flatbuffers;
var FlatbufPlaces = require("../utils/flatbuffers/households_generated").Flatbuf; // Generated by flatc compiler.
// import { Flatbuf } from '../utils/flatbuffers/households_generated';
var FlatbufPeople = require("../utils/flatbuffers/people_generated").Flatbuf; // Generated by flatc compiler.

const mapBounds = require("../utils/mapBounds");

class Place {
    xpos: number = 0;
    ypos: number = 0;
    residents: number[] = [];
    currentOccupants: util.FastArrayInt32;

    constructor(readonly lat: number, readonly lon: number, readonly capacity: number, readonly county: number = -1) {
        this.currentOccupants = new util.FastArrayInt32(capacity);
    }

    latLonToPos(sim: Sim) {
        [this.xpos, this.ypos] = sim.latLonToPos(this.lat, this.lon);
    }
    static genPlace(sim: Sim, lat: any, lon: any, capacity: number): Place {
        let lat2: any = lat!;
        let lon2: any = lon!;
        let hh = new Place(parseFloat(lat2), parseFloat(lon2), capacity);
        hh.latLonToPos(sim);
        return hh;
    }
}

var img: any;
export function loadImage(url: string):any {
    return new Promise(r => {
        console.log("Loading: " + url);
        let i = new Image();
        i.onload = () => r(i);
        i.src = url;
        // if (i.width == 0) alert("ERROR: Probably couldn't load jpg map image.");
    });
}

export class Sim {
    params: Params.Base;
    rand: RandomFast;
    // These store all the Person info for the whole population.
    // Have 2 parallel arrays for cache reasons.
    pop: Person[] = [];
    popTight: PersonTight[] = [];

    // Array of arrays of arrays
    // each outer array is a different kind of place, like home, office, supermarket.
    // next array is all the places of that type
    // next array is indexes to people currently occupying Places... This has more info than just that array.
    allPlaces: Array<Array<Place>> = [];

    supermarketJSON: any; // hold onto this info so we can get place names for visualization purposes
    latMin: number = 0;
    latMax: number = 0;
    lonMin: number = 0;
    lonMax: number = 0;
    latAdjust: number = 0;
    countyPolygons: number[][] = [];
    allCountyBounds: any = [];

    time_steps_since_start: Params.TimeStep = new Params.TimeStep();

    selectedHouseholdIndex = -1;
    selectedPersonIndex = 0;
    lastMouseX = -1;
    lastMouseY = -1;
    selectedCountyIndex = -1;

    wasmSim: any = null;
    useWasmSim: boolean = false; // turn WASM sim backend on via this flag

    // ---- visuals ----
    canvasWidth = 0;
    canvasHeight = 0;
    scalex = 1;
    scaley = 1;
    paused = false;
    infectedVisuals: any[][] = [];
    infectionTraces: any[] = [];
    visualsFlag = util.VizFlags.traces;
    countyStats: CountyStats = new CountyStats();

    constructor(params: Params.Base) {
        this.params = params;
        // this.rand = new MersenneTwister(params.randomSeed);
        this.rand = new RandomFast(params.randomSeed);
    }
    // Normalizes positions so they are in the [0..1] range on x and y.
    // Returns [x, y] tuple.
    latLonToPos(lat: number, lon: number): number[] {
        let maxDelta = Math.max(this.lonMax - this.lonMin, (this.latMax - this.latMin) / this.latAdjust);
        let xpos = (lon - this.lonMin) / maxDelta;
        let ypos = (this.latMax - lat) / maxDelta; // Flip and make it relative to the top since graphics coords are from upper-left
        ypos /= this.latAdjust; // Adjust for curved earth
        return [xpos, ypos];
    }
    latLonDistKm(latA: number, lonA: number, latB: number, lonB: number): number {
        let dx = (lonB - lonA) * this.latAdjust;
        let dy = latB - latA;
        let dx_km = dx * 111.32;
        let dy_km = dy * 110.574;
        return Math.sqrt(dx_km * dx_km + dy_km * dy_km);
    }

    async setup() {
        console.log("-------- SETUP --------");
        // Load lat/lon bounds
        let jsonTemp1 = await fetch("datafiles/" + mapBounds.defaultPlace + "_AllCountyBounds.json");
        this.allCountyBounds = await jsonTemp1.json();
        // -1 indexes the bounds for all the counties, not just one.
        this.latMin = this.allCountyBounds["-1"]["min"][0];
        this.latMax = this.allCountyBounds["-1"]["max"][0];
        this.lonMin = this.allCountyBounds["-1"]["min"][1];
        this.lonMax = this.allCountyBounds["-1"]["max"][1];
        this.latAdjust = Math.cos(util.toRadians((this.latMin + this.latMax) * 0.5)); // Adjust for curved earth (approximately with a point)

        // TODO: use promise.all() on all these awaits???
        img = await loadImage("datafiles/" + mapBounds.info[mapBounds.defaultPlace].mapImage);

        // -------- Load county polygon info --------
        {
            let jsonTemp0 = await fetch("datafiles/" + mapBounds.defaultPlace + "_CountyPolygons.json");
            this.countyPolygons = await jsonTemp0.json();
        }

        // -------- Load HOUSE position and size data --------
        {
            let jsonTempA = await fetch("datafiles/" + mapBounds.defaultPlace + "_Supermarkets.json");
            this.supermarketJSON = await jsonTempA.json();
        }

        let jsonTempB = await fetch("datafiles/" + mapBounds.defaultPlace + "_Hospitals.json");
        let hospitalJSON = await jsonTempB.json();

        // -------- Load HOUSE position and size data --------
        {
            let timer = performance.now();
            let fetchTemp = await fetch("datafiles/" + mapBounds.defaultPlace + "_Households.fb"); // flatbuffer
            let homeDataAB = await fetchTemp.arrayBuffer();
            let buf = new flatbuffers.ByteBuffer(new Uint8Array(homeDataAB));
            // Get an accessor to the root object inside the buffer.
            let hhi = FlatbufPlaces.PlaceArray.getRootAsPlaceArray(buf);
            let placeLen = hhi.placeLength();
            this.allPlaces[PlaceType.home] = [];
            for (let i = 0; i < placeLen; i++) {
                let one = hhi.place(i);
                this.allPlaces[PlaceType.home].push(new Place(one.lat(), one.lon(), one.capacity(), one.countyIndex()));
            }
            let totalHomeCapacity = hhi.totalHomeCapacity();
            console.log("loaded homes in: " + (performance.now() - timer).toFixed(0) + "ms");

            console.log("Total home capacity from file: " + totalHomeCapacity);
            console.log("Total households: " + this.allPlaces[PlaceType.home].length);
            console.log("Average household size: " + totalHomeCapacity / this.allPlaces[PlaceType.home].length);
        }

        // let timer = performance.now();
        // let jsonTemp = await fetch("datafiles/" + mapBounds.defaultPlace + "_Households.json");
        // let homeDataJSON = await jsonTemp.json();
        // this.allHouseholds = [];
        // let totalHomeCapacity = 0;
        // for (const p of homeDataJSON) {
        //     this.allHouseholds.push(new Place(p[0], p[1], p[2], p[3]));
        //     totalHomeCapacity += p[2];
        // }
        // console.log("loaded homes in: " + (performance.now() - timer).toFixed(0) + "ms");

        // -------- Load OFFICE position and size data --------
        {
            let jsonTempJ = await fetch("datafiles/" + mapBounds.defaultPlace + "_Offices.json");
            let officeDataJSON = await jsonTempJ.json();
            this.allPlaces[PlaceType.office] = [];
            let totalOfficeCapacity = 0;
            for (const p of officeDataJSON) {
                this.allPlaces[PlaceType.office].push(new Place(p[0], p[1], p[2]));
                totalOfficeCapacity += p[2];
            }
            console.log("Total office capacity from file: " + totalOfficeCapacity);
            console.log("Total offices: " + this.allPlaces[PlaceType.office].length);
            console.log("Average office size: " + totalOfficeCapacity / this.allPlaces[PlaceType.office].length);
        }

        this.allPlaces[PlaceType.supermarket] = [];
        this.allPlaces[PlaceType.hospital] = [];
        for (const sm of this.supermarketJSON)
            this.allPlaces[PlaceType.supermarket].push(Place.genPlace(this, sm[0], sm[1], 200)); // TODO: supermarket capacity???
        for (const h of hospitalJSON) this.allPlaces[PlaceType.hospital].push(Place.genPlace(this, h[0], h[1], 200)); // TODO: hospital capacity???

        for (let i = 0; i < this.allPlaces[PlaceType.home].length; i++) this.allPlaces[PlaceType.home][i].latLonToPos(this);
        for (let i = 0; i < this.allPlaces[PlaceType.office].length; i++) this.allPlaces[PlaceType.office][i].latLonToPos(this);

        this.countyStats.init(mapBounds.info[mapBounds.defaultPlace].includedCounties.length);

        // -------- Load PEOPLE info from flatbuffer --------
        console.log("Generating people data...");
        let timer = performance.now();
        let tempF = await fetch("datafiles/" + mapBounds.defaultPlace + "_FinalPeople.fb");
        let peopleDataAB = await tempF.arrayBuffer();
        let buf = new flatbuffers.ByteBuffer(new Uint8Array(peopleDataAB));
        // Get an accessor to the root object inside the buffer.
        let personfb = FlatbufPeople.PersonArray.getRootAsPersonArray(buf);
        let peopleLen = personfb.peopleLength();
        this.pop = [];
        this.popTight = [];
        let totalAge = 0;
        // Allocate people to their houses and offices.
        for (let i = 0; i < peopleLen; i++) {
            let personTight = new PersonTight();
            let person = new Person(this.params, this.rand, this.pop.length, personTight);
            let source = personfb.people(i);
            person.county = source.countyIndex();
            personTight.placeIndex[PlaceType.home] = source.homeIndex();
            personTight.placeIndex[PlaceType.office] = source.officeIndex();
            personTight.placeIndex[PlaceType.supermarket] = source.supermarketIndex();
            personTight.placeIndex[PlaceType.hospital] = source.hospitalIndex();
            person.age = source.age();
            person.maleFemale = source.maleFemale();
            totalAge += source.age();
            let home = this.allPlaces[PlaceType.home][personTight.placeIndex[PlaceType.home]];
            home.residents.push(person.id);
            person.xpos = home.xpos;
            person.ypos = home.ypos;
            person.infectedX = home.xpos;
            person.infectedY = home.ypos;
            this.allPlaces[PlaceType.office][personTight.placeIndex[PlaceType.office]].residents.push(person.id);
            this.allPlaces[PlaceType.supermarket][personTight.placeIndex[PlaceType.supermarket]].residents.push(person.id);
            this.allPlaces[PlaceType.hospital][personTight.placeIndex[PlaceType.hospital]].residents.push(person.id);
            this.popTight.push(personTight);
            this.pop.push(person);
            if (person.county >= 0) this.countyStats.counters[person.county][GraphType.startingPopulation]++;
        }
        console.log("average age: " + (totalAge * 1.0) / this.pop.length);
        console.log("loaded homes in: " + (performance.now() - timer).toFixed(0) + "ms");

        console.log("total people: " + this.pop.length);

        if (this.useWasmSim) {
            await this.initWasmSim();
        } else {
            for (let j = 0; j < this.pop.length; j++) {
                this.pop[j].init(this.params, this.rand);
            }
        }

        // this.pop.index(1).occupation = 1;
        // let near = this.pop.findKNearest(1, 4);
        // for (let i = 0; i < near.length; i++) {
        //     this.pop.index(near[i]).occupation = 2;
        // }
        // this.pop.index(near).occupation = 2;
        // for (let i = 0; i < 31; i++) {
        //     this.pop[i].becomeSick(this);
        // }

        this.pop[this.selectedPersonIndex].drawTimeline(<HTMLCanvasElement>document.getElementById("timeline-canvas"));
        window.requestAnimationFrame(() => this.draw());
    }

    async testRNG() {
        console.log("Testing RNG implementations");

        let tsRand = new RandomFast(this.params.randomSeed);
        let wasmRand = new moduleInstance.RandomFast(this.params.randomSeed);
        let ntrials = 10;

        console.log("RandomFast.SmallHashA");
        for (let i = 0; i < ntrials; i++) {
            // console.log(i + " ts= " + RandomFast.SmallHashA(i) + "wasm=" + moduleInstance.RandomFast.SmallHashA(i));
            util.assert(RandomFast.SmallHashA(i) === moduleInstance.RandomFast.SmallHashA(i), "smallhash error");
        }

        console.log("RandFloat");
        for (let i = 0; i < ntrials; i++) {
            // console.log(i + " ts= " + tsRand.RandFloat() + "wasm=" + wasmRand.RandFloat());
            util.assert(tsRand.RandFloat() === wasmRand.RandFloat(), "randfloat error");
        }

        console.log("HashIntApprox");
        for (let i = 0; i < ntrials; i++) {
            // console.log(i + " ts= " + RandomFast.HashIntApprox(i, 0, 10000) + "wasm=" + moduleInstance.RandomFast.HashIntApprox(i, 0, 10000));
            util.assert(RandomFast.HashIntApprox(i, 0, 1000000) === moduleInstance.RandomFast.HashIntApprox(i, 0, 1000000));
        }

        // Test overhead of wasm call. Seems too big to call small functions. :(
        // C++ function should be faster if no overhead because JS does inefficient multiplies.
        ntrials = 100;
        let total = 0.0;
        let timer = performance.now();
        for (let i = 0; i < ntrials; i++) total += tsRand.RandFloat();
        console.log("ts   rand: " + (performance.now() - timer).toFixed(0) + "ms " + total.toFixed(2)); // 150 ms for 10 mil iterations

        total = 0.0;
        timer = performance.now();
        for (let i = 0; i < ntrials; i++) total += wasmRand.RandFloat();
        console.log("wasm rand: " + (performance.now() - timer).toFixed(0) + "ms " + total.toFixed(2)); // 900 ms for 10 mil iterations
    }

    async initWasmSim() {
        this.paused = true; // locks the sim while loading
        console.log("Loading wasm module");
        await Module().then(function(loadedModule: any) {
            moduleInstance = loadedModule;
        });
        console.log("Loaded wasm module");
        this.paused = false;

        // test RNG
        await this.testRNG();

        // sets up the activities
        for (var j = 0; j < Person.activitiesNormal.length; j++) {
            moduleInstance.Sim.registerNormalActivitySchedule(Person.activitiesNormal[j]);
        }
        for (var j = 0; j < Person.activitiesWhileSick.length; j++) {
            moduleInstance.Sim.registerSickActivitySchedule(Person.activitiesWhileSick[j]);
        }

        this.wasmSim = new moduleInstance.Sim(this.pop.length);
        this.wasmSim.setNumberOfPlacesForActivity("h", this.allPlaces[PlaceType.home].length, this.params.home_density);
        this.wasmSim.setNumberOfPlacesForActivity("w", this.allPlaces[PlaceType.office].length, this.params.office_density);
        this.wasmSim.setNumberOfPlacesForActivity(
            "s",
            this.allPlaces[PlaceType.supermarket].length,
            this.params.shopping_density
        );
        // not used in reference js yet: this.occupantCounter.setNumberOfPlacesForActivity('o', this.allHospitals.length);

        for (var j = 0; j < this.pop.length; j++) {
            let person: Person = this.pop[j];
            let personTight: PersonTight = this.popTight[j];
            var placeIndexArray = new moduleInstance.int_vector();
            placeIndexArray.push_back(personTight.placeIndex[PlaceType.home]);
            placeIndexArray.push_back(personTight.placeIndex[PlaceType.office]);
            placeIndexArray.push_back(personTight.placeIndex[PlaceType.supermarket]);
            this.wasmSim.addPerson(
                new moduleInstance.PersonCore(person.id, placeIndexArray, person.getPersonDefaultRoutineIndex())
            );
            placeIndexArray.delete(); // annoying!
        }

        console.log("associateWasmSimAndInit start");

        for (var j = 0; j < this.pop.length; j++) {
            this.pop[j].associateWasmSimAndInit(this.wasmSim, this.params, this.rand);
        }

        this.wasmSim.prepare();

        // ************************ DEBUGGING TEST ***********************
        testWasmArraySharing(moduleInstance);

        console.log("associateWasmSimAndInit finish");
    }

    // Infect someone RANDOM in a certain county. This is just for getting things started.
    seedInfection(countyIndex: number) {
        let i = util.randint(this.rand, 0, this.pop.length);
        while (this.pop[i].county != countyIndex && this.pop[i].isVulnerable) i = util.randint(this.rand, 0, this.pop.length);
        this.pop[i].becomeSick(this);
    }

    clearOccupants() {
        const ap = this.allPlaces;
        for (let i = 0; i < numPlaceTypes; i++) {
            const placeList = ap[i];
            for (let j = 0; j < placeList.length; j++) placeList[j].currentOccupants.reset();
        }
    }
    // Allocate all the people to the places they will occupy for this timestep.
    occupyPlaces() {
        this.clearOccupants();
        const currentStep = this.time_steps_since_start.getStepModDay();
        const t_pop = this.popTight;
        const t_allPlaces = this.allPlaces;
        for (let i = 0; i < t_pop.length; i++) {
            let personTight = t_pop[i];
            // Can make allPlaces into 2 structs for cache happy

            // Sets activity for this time step
            let activity = personTight.currentRoutine[currentStep];
            if (activity >= numPlaceTypes) continue;
            // personTight.currentActivity = activity;
            let placeIndex = personTight.placeIndex[activity];
            t_allPlaces[activity][placeIndex].currentOccupants.push(i);
        }
    }
    run_simulation(num_time_steps: number) {
        if (this.useWasmSim) {
            this.runWasmSimulation(num_time_steps);
            return;
        }
        for (let ts = 0; ts < num_time_steps; ts++) {
            this.params.doInterventionsForThisTimestep(this);
            this.occupyPlaces();
            for (let i = 0; i < this.pop.length; i++) {
                let person = this.pop[i];
                person.stepTime(this, this.rand);
                person.spread(this.time_steps_since_start, i, this.pop, this.rand, this);
            }
            this.time_steps_since_start.increment();

            // Update graphs with latest stats
            this.countyStats.updateTimeSeriesFromCounters();
        }
    }

    runWasmSimulation(num_time_steps: number) {
        for (let ts = 0; ts < num_time_steps; ts++) {
            this.params.doInterventionsForThisTimestep(this);

            // occupy places
            let currentStep = this.time_steps_since_start.getStepModDay();
            this.wasmSim.getOccupantCounter().countAndFillLists(currentStep);

            // calls wasm sim backend
            this.wasmSim.runPopulationStep(this.time_steps_since_start.raw);

            // update stats, given output of wasm sim
            var arr = this.wasmSim.lastStepInfected;
            for (let i = 0; i < arr.size(); i++) {
                let p = this.pop[arr.get(i)];
                this.countyStats.counters[p.county][GraphType.totalInfected]++;
                this.countyStats.counters[p.county][GraphType.currentInfected]++;
            }
            arr.delete();

            arr = this.wasmSim.lastStepRecovered;
            for (let i = 0; i < arr.size(); i++) {
                let p = this.pop[arr.get(i)];
                this.countyStats.counters[p.county][GraphType.currentInfected]--;
            }
            arr.delete();

            arr = this.wasmSim.lastStepDead;
            for (let i = 0; i < arr.size(); i++) {
                let p = this.pop[arr.get(i)];
                this.countyStats.counters[p.county][GraphType.totalDead]++;
                this.countyStats.counters[p.county][GraphType.currentInfected]--;
            }
            arr.delete();

            this.time_steps_since_start.increment();

            // Update graphs with latest stats
            this.countyStats.updateTimeSeriesFromCounters();
        }
    }

    drawLine(ctx: any, x0: number, y0: number, x1: number, y1: number, color: string) {
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(x0 * this.scalex, y0 * this.scaley);
        ctx.lineTo(x1 * this.scalex, y1 * this.scaley);
        ctx.closePath();
        ctx.stroke();
    }

    drawText(ctx: any, x: number, y: number, text: string, size: number = 16, color: string = "rgb(255, 255, 255)") {
        ctx.fillStyle = color;
        ctx.font = size.toString() + "px sans-serif";
        ctx.fillText(text, x * this.scalex, y * this.scaley);
    }

    drawCircle(ctx: any, x: number, y: number, radius: number, color: string = "rgb(255, 255, 255)", fill: boolean = true) {
        ctx.beginPath();
        ctx.arc(x * this.scalex, y * this.scaley, radius, 0, 2 * Math.PI);
        ctx.closePath();
        if (fill) {
            ctx.fillStyle = color;
            ctx.fill();
        } else {
            ctx.strokeStyle = color;
            ctx.stroke();
        }
    }

    drawRect(
        ctx: any,
        x: number,
        y: number,
        width: number,
        height: number,
        color: string = "rgb(255, 255, 255)",
        fill: boolean = true
    ) {
        if (fill) {
            ctx.fillStyle = color;
            ctx.fillRect(x * this.scalex, y * this.scaley, width * this.scalex, height * this.scaley);
        } else {
            ctx.strokeStyle = color;
            ctx.drawRect(x * this.scalex, y * this.scaley, width * this.scalex, height * this.scaley);
        }
    }

    draw() {
        const canvas = <HTMLCanvasElement>document.getElementById("map-canvas");
        if (canvas.getContext) {
            const ctx = canvas.getContext("2d");
            if (!ctx) return;
            // ctx.setTransform(this.zoom, 0, 0, this.zoom, this.centerx-canvas.width*0.5, this.centery-canvas.height*0.5);

            // Store the current transformation matrix
            ctx.save();
            // Use the identity matrix while clearing the canvas
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Restore the transform
            ctx.restore();

            let imgWidth: number = img.width;
            let imgHeight: number = img.height;
            let imgMax = Math.max(imgWidth, imgHeight);
            let maxCanvas = Math.max(canvas.width, canvas.height);
            let ratio = maxCanvas / imgMax;
            [this.canvasWidth, this.canvasHeight] = [canvas.width, canvas.height];
            this.scalex = maxCanvas;
            this.scaley = maxCanvas;

            ctx.globalAlpha = 0.5;
            if (this.visualsFlag > 0) ctx.globalAlpha = 0.25;
            ctx.drawImage(img, 0, 0, imgWidth * ratio, imgHeight * ratio);
            ctx.globalAlpha = 1.0;

            // Draw selected county polygon outline and fill
            if (this.selectedCountyIndex >= 0) {
                ctx.lineWidth = 3;
                ctx.fillStyle = "#00ff4410";
                ctx.beginPath();
                // TODO: This is slow to convert latlon every draw. fixme.
                let poly: any = this.countyPolygons[this.selectedCountyIndex];
                let lastPos = this.latLonToPos(poly[0][0], poly[0][1]);
                ctx.moveTo(lastPos[0] * this.scalex, lastPos[1] * this.scaley);
                for (let i = 0; i < poly.length; i++) {
                    let pos = this.latLonToPos(poly[i][0], poly[i][1]);
                    ctx.lineTo(pos[0] * this.scalex, pos[1] * this.scaley);
                    lastPos = pos;
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = "#f2bb07";
                ctx.stroke();
                ctx.lineWidth = 1.0;
            }

            // ---- Draw selected *household* info ----
            if (this.selectedHouseholdIndex >= 0) {
                let hh: Place = this.allPlaces[PlaceType.home][this.selectedHouseholdIndex];

                this.drawCircle(ctx, hh.xpos, hh.ypos, 8, "rgb(255,128,0)", false);

                this.drawText(ctx, hh.xpos + 0.02, hh.ypos, hh.residents.length.toString());
                for (let i = 0; i < hh.residents.length; i++) {
                    let popIndex = hh.residents[i];
                    let person: Person = this.pop[popIndex];
                    let personTight: PersonTight = this.popTight[popIndex];
                    let office = this.allPlaces[PlaceType.office][personTight.placeIndex[PlaceType.office]];
                    let market = this.allPlaces[PlaceType.supermarket][personTight.placeIndex[PlaceType.supermarket]];
                    this.drawLine(
                        ctx,
                        hh.xpos + RandomFast.HashFloat(i) * 0.02 - 0.01,
                        hh.ypos + RandomFast.HashFloat(i + 1000) * 0.02 - 0.01,
                        market.xpos,
                        market.ypos,
                        RandomFast.HashRGB(i)
                    );
                }
            }
            // ---- Draw selected *person*'s places ----
            if ((this.visualsFlag & util.VizFlags.person) != 0 && this.selectedPersonIndex >= 0) {
                let p: Person = this.pop[this.selectedPersonIndex];
                let pTight: PersonTight = this.popTight[this.selectedPersonIndex];
                let market = this.allPlaces[PlaceType.supermarket][pTight.placeIndex[PlaceType.supermarket]];
                let house = this.allPlaces[PlaceType.home][pTight.placeIndex[PlaceType.home]];
                let office = this.allPlaces[PlaceType.office][pTight.placeIndex[PlaceType.office]];
                let hospital = this.allPlaces[PlaceType.hospital][pTight.placeIndex[PlaceType.hospital]];

                let [localx, localy] = p.getCurrentLocation(this, -1);
                // p.xpos = (p.xpos + localx) * 0.5;
                // p.ypos = (p.ypos + localy) * 0.5;
                let px = localx;
                let py = localy;

                this.drawLine(ctx, px, py, market.xpos, market.ypos, "rgba(60, 255, 60, 0.5)");
                this.drawLine(ctx, px, py, house.xpos, house.ypos, "rgba(0, 0, 0, 0.5)");
                this.drawLine(ctx, px, py, office.xpos, office.ypos, "rgba(160, 160, 160, 0.5)");
                this.drawLine(ctx, px, py, hospital.xpos, hospital.ypos, "rgba(255, 25, 20, 0.5)");
                this.drawText(ctx, market.xpos - 0.0125, market.ypos, "🏪");
                this.drawText(ctx, house.xpos - 0.0125, house.ypos, "🏡");
                this.drawText(ctx, office.xpos - 0.0125, office.ypos, "🏢");
                this.drawText(ctx, hospital.xpos - 0.0125, hospital.ypos, "🏥");
                this.drawText(ctx, px, py, "😃");
            }

            if ((this.visualsFlag & util.VizFlags.pop10) != 0) {
                // Rendering is by far the bottleneck, so target this many rendered points and skip the rest.
                let skip = 10;
                for (let i = 0; i < this.pop.length; i += skip) {
                    let person = this.pop[i];
                    let personTight: PersonTight = this.popTight[i];
                    let pos = [person.xpos, person.ypos];
                    let currentStep = this.time_steps_since_start.getStepModDay(); // Should this be time_step - 1????
                    let activity = personTight.getCurrentActivityInt(currentStep);
                    // let activity = person.currentActivity;
                    if (activity == PlaceType.home) {
                        let p = this.allPlaces[PlaceType.home][personTight.placeIndex[PlaceType.home]];
                        pos = [p.xpos, p.ypos];
                        ctx.fillStyle = "#ccbb50";
                    } else if (activity == PlaceType.office) {
                        let p = this.allPlaces[PlaceType.office][personTight.placeIndex[PlaceType.office]];
                        pos = [p.xpos, p.ypos];
                        ctx.fillStyle = "#00bbff";
                    } else if (activity == PlaceType.supermarket) {
                        let p = this.allPlaces[PlaceType.supermarket][personTight.placeIndex[PlaceType.supermarket]];
                        pos = [p.xpos, p.ypos];
                        ctx.fillStyle = "#88ff88";
                    } else {
                        ctx.fillStyle = "#dd8888";
                    }

                    ctx.fillRect(pos[0] * this.scalex, pos[1] * this.scaley, 1, 1);
                }
            }
            ctx.fillStyle = "#ffffff";
            if ((this.visualsFlag & util.VizFlags.homes) != 0) {
                for (let i = 0; i < this.allPlaces[PlaceType.home].length; i++) {
                    let house = this.allPlaces[PlaceType.home][i];
                    if (this.selectedCountyIndex == -1 || house.county == this.selectedCountyIndex)
                        ctx.fillRect(house.xpos * this.scalex, house.ypos * this.scaley, 1, 1);
                }
            }
            if ((this.visualsFlag & util.VizFlags.offices) != 0) {
                for (let i = 0; i < Math.min(1000000, this.allPlaces[PlaceType.office].length); i++) {
                    let office = this.allPlaces[PlaceType.office][i];
                    ctx.fillRect(office.xpos * this.scalex, office.ypos * this.scaley, 1, 1);
                }
            }
            if ((this.visualsFlag & util.VizFlags.hospitals) != 0) {
                for (let i = 0; i < this.allPlaces[PlaceType.hospital].length; i++) {
                    let hospital = this.allPlaces[PlaceType.hospital][i];
                    // Draw a happy little red cross because there's no red cross emoji.
                    this.drawCircle(ctx, hospital.xpos, hospital.ypos, 0.008 * this.scalex, "#ffffff", true);
                    this.drawRect(ctx, hospital.xpos - 0.006, hospital.ypos - 0.002, 0.012, 0.004, "rgb(255, 64, 64)");
                    this.drawRect(ctx, hospital.xpos - 0.002, hospital.ypos - 0.006, 0.004, 0.012, "rgb(255, 64, 64)");
                }
            }
            if ((this.visualsFlag & util.VizFlags.supermarkets) != 0) {
                for (let i = 0; i < this.allPlaces[PlaceType.supermarket].length; i++) {
                    let market = this.allPlaces[PlaceType.supermarket][i];
                    this.drawRect(ctx, market.xpos, market.ypos, 0.005, 0.005, "rgb(60, 255, 60)");
                }
            }
            if ((this.visualsFlag & util.VizFlags.susceptible) != 0) {
                for (let i = 0; i < this.pop.length; i++) {
                    let person = this.pop[i];
                    if (person.isVulnerable) ctx.fillRect(person.xpos * this.scalex, person.ypos * this.scaley, 1, 1);
                }
            }
            if ((this.visualsFlag & util.VizFlags.infected) != 0) {
                for (let i = 0; i < this.pop.length; i++) {
                    let person = this.pop[i];
                    if (person.isSick) ctx.fillRect(person.xpos * this.scalex, person.ypos * this.scaley, 1, 1);
                }
            }
            if ((this.visualsFlag & util.VizFlags.recovered) != 0) {
                for (let i = 0; i < this.pop.length; i++) {
                    let person = this.pop[i];
                    if (person.isRecovered) ctx.fillRect(person.xpos * this.scalex, person.ypos * this.scaley, 1, 1);
                }
            }
            // for (let i = 0; i < businessJSON.length; i++) {
            //     let business = businessJSON[i];
            //     let lat: any = business[0]!;
            //     let lon: any = business[1]!;

            //     let [x, y] = this.latLonToPos(parseFloat(lat), parseFloat(lon));
            //     this.drawRect(ctx, x, y, 0.0015, 0.002, "rgb(255, 0, 255)");
            // }

            // Reference point to check lat/lon
            // let [x, y] = this.latLonToPos(37.7615, -122.44);  // middle of range
            // this.drawCircle(ctx, x, y, 2, "rgb(60, 255, 240)");
            // [x, y] = this.latLonToPos(37.810515, -122.424476);  // aquatic park
            // this.drawCircle(ctx, x, y, 2, "rgb(6, 155, 240)");
            // [x, y] = this.latLonToPos(37.774746, -122.454676);  // upper right of GG park
            // this.drawCircle(ctx, x, y, 2, "rgb(60, 255, 40)");
            // [x, y] = this.latLonToPos(37.708787, -122.374493);  // east candlestick point
            // this.drawCircle(ctx, x, y, 2, "rgb(160, 255, 40)");

            if ((this.visualsFlag & util.VizFlags.traces) != 0) {
                // Animate infection circles and delete things from the list that are old.
                let tempIV: number[][] = [];
                ctx.lineWidth = 1.5;
                for (let i = 0; i < this.infectedVisuals.length; i++) {
                    let t = (this.time_steps_since_start.hours - this.infectedVisuals[i][2].hours) / 2;
                    let alpha = Math.max(0, 60 - t) / 60.0;
                    if (alpha > 0.0) tempIV.push(this.infectedVisuals[i]);

                    const maxDraws = 32; // Limit the number of circles that can be drawn for performance.
                    if (i > this.infectedVisuals.length - maxDraws) {
                        let x = this.infectedVisuals[i][0];
                        let y = this.infectedVisuals[i][1];
                        this.drawCircle(ctx, x, y, t + 2, "rgba(255,100,10," + alpha.toString() + ")", false);
                    }
                }
                this.infectedVisuals = tempIV;
                ctx.lineWidth = 1.0;

                // Draw lines connecting where people got infected.
                if (this.infectionTraces.length > 64) this.infectionTraces = this.infectionTraces.slice(this.infectionTraces.length - 64);  // fifo queue
                for (let i = 0; i < this.infectionTraces.length; i++) {
                    let trace = this.infectionTraces[i];
                    if (trace[0] == trace[2] && trace[1] == trace[3]) this.drawRect(ctx, trace[0] - 0.001, trace[1] - 0.001, 0.002, 0.002, "#ffff00");
                    else this.drawLine(ctx, trace[0], trace[1], trace[2], trace[3], "#ff680a");
                }
            }

            // Draw map lat/lon extents around the map
            this.drawText(ctx, 0.45, -0.01, "max lat: " + this.latMax);
            this.drawText(ctx, 0.45, 1.02 * this.latAdjust, "min lat: " + this.latMin);
            this.drawText(ctx, -0.215, 0.49 * this.latAdjust, "min lon: " + this.lonMin);
            this.drawText(ctx, 1.01, 0.49 * this.latAdjust, "max lon: " + this.lonMax);

            // // Look at Google timeline data
            // for (let i = 0; i < 100; i++) {
            //     let slide = this.time_steps_since_start + i + 2200;
            //     let lat = Number.parseFloat(allLocations[slide].latitudeE7) * 0.0000001;
            //     let lon = Number.parseFloat(allLocations[slide].longitudeE7) * 0.0000001;
            //     // console.log(lat + ", " + lon);

            //     let [x,y] = this.latLonToPos(lat, lon);
            //     this.drawCircle(ctx, x, y, .2, "rgb(255,255,2)");
            // }

            // console.log(peopleJSON);

            // // Look at Population density people
            // for (let i = 0; i < peopleJSON.length; i += 100) {
            //     let p = peopleJSON[i];
            //     let lat = Number.parseFloat(p[0]);
            //     let lon = Number.parseFloat(p[1]);
            //     let [x, y] = this.latLonToPos(lat, lon);
            //     this.drawCircle(ctx, x, y, 0.5, "#ffff02");
            //     // ctx.fillRect((x * this.scalex) | 0, (y * this.scaley) | 0, 2, 2);
            // }

            this.countyStats.drawGraph(Math.max(0, this.selectedCountyIndex), this.params);
            // ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
    }
    controllerClick(x: number, y: number) {
        return;
        // x = (x / this.scalex) * this.canvasWidth;
        // y = (y / this.scaley) * this.canvasHeight;
        // // If we're not actively dragging something, let people drag the phone screen.
        // // if (this.mouse.mode != -1) event.preventDefault();
        // // console.log(x.toString() + "   " + y.toString());
        // let bestIndex = -1;
        // let bestDist = Number.MAX_VALUE;
        // for (let i = 0; i < this.allPlaces[PlaceType.home].length; i++) {
        //     let hh = this.allPlaces[PlaceType.home][i];
        //     let xp = hh.xpos;
        //     let yp = hh.ypos;
        //     let dx = xp - x;
        //     let dy = yp - y;
        //     let distSq = dx * dx + dy * dy;
        //     if (distSq < bestDist && hh.residents.length > 0) {
        //         bestDist = distSq;
        //         bestIndex = i;
        //     }
        // }
        // this.selectedHouseholdIndex = bestIndex;
        // let hh = this.allPlaces[PlaceType.home][this.selectedHouseholdIndex];
        // console.log("capactity: " + hh.capacity + ",    residents: " + hh.residents.length);

        // this.lastMouseX = x;
        // this.lastMouseY = y;
        // this.draw();
    }
    playPause() {
        if (this.paused) this.paused = false;
        else this.paused = true;

        this.draw();
    }
    translation(dx: number, dy: number) {
        const canvas = <HTMLCanvasElement>document.getElementById("map-canvas");
        if (canvas.getContext) {
            const ctx = canvas.getContext("2d");
            if (!ctx) return;
            let storedTransform = ctx.getTransform();
            let cx = storedTransform.e;
            let cy = storedTransform.f;
            let cscale = storedTransform.a; // assume aspect ratio 1

            ctx.translate(-dx / cscale, -dy / cscale);
        }
        this.draw();
    }
    changeZoom(scale: number) {
        const canvas = <HTMLCanvasElement>document.getElementById("map-canvas");
        if (canvas.getContext) {
            const ctx = canvas.getContext("2d");
            if (!ctx) return;
            let storedTransform = ctx.getTransform();
            let cx = storedTransform.e;
            let cy = storedTransform.f;
            let cscale = storedTransform.a; // assume aspect ratio 1
            let amount = 1.03125;
            if (scale > 0) {
                ctx.translate(canvas.width * 0.5, canvas.height * 0.5);
                ctx.scale(1 / amount, 1 / amount);
                ctx.translate(-canvas.width * 0.5, -canvas.height * 0.5);
            } else {
                ctx.translate(canvas.width * 0.5, canvas.height * 0.5);
                ctx.scale(amount, amount);
                ctx.translate(-canvas.width * 0.5, -canvas.height * 0.5);
            }
        }
        this.draw();
    }
}

// ****************************************************************************
// **                        WASM EXPERIMENTS WIP                            **
// ****************************************************************************

// Alloc typed array to be shared between C++ and JS code.
// Returns JS typed array and C++ pointer.
function allocUint32Array(moduleInstance: any, size: number): [Uint32Array, number] {
    const BYTES_PER_ELEMENT = 4;
    const LOG2_BYTES_PER_ELEMENT = 2;
    let ptr;
    let jsArray: Uint32Array;
    try {
        // Allocate some space in the heap for the data (making sure to use the appropriate memory size of the elements)
        ptr = moduleInstance._malloc(size * BYTES_PER_ELEMENT);
        jsArray = moduleInstance.HEAPU32.subarray(ptr >> LOG2_BYTES_PER_ELEMENT, (ptr >> LOG2_BYTES_PER_ELEMENT) + size);

        // Finally, call the function with "number" parameter type for the array (the pointer), and an extra length parameter
        // result = moduleInstance.ccall("addNums", null, ["number", "number"], [ptr, arrayDataToPass.length])
        // result = ll.addNums(ptr, arrayDataToPass.length);
    } catch (e) {
        console.log("ERROR: " + e);
        moduleInstance._free(ptr);
        jsArray = new Uint32Array();
    } finally {
        // To avoid memory leaks we need to always clear out the allocated heap data
        // This needs to happen in the finally block, otherwise thrown errors will stop code execution before this happens
        // moduleInstance._free(ptr)
    }

    return [jsArray, ptr];
}

function testWasmArraySharing(moduleInstance: any) {
    let ll = new moduleInstance.LowLevel();
    ll.test();

    const arrayDataToPass = [1, 2, 3, 4, 5];
    let buffer;
    let error;
    let result;
    try {
        // Init the typed array with the same length as the number of items in the array parameter
        const typedArray = new Float32Array(arrayDataToPass.length);

        // Populate the array with the values
        for (let i = 0; i < arrayDataToPass.length; i++) {
            typedArray[i] = arrayDataToPass[i];
        }

        // Allocate some space in the heap for the data (making sure to use the appropriate memory size of the elements)
        buffer = moduleInstance._malloc(typedArray.length * typedArray.BYTES_PER_ELEMENT);

        // Assign the data to the heap - Keep in mind bytes per element
        moduleInstance.HEAPF32.set(typedArray, buffer >> 2);
        var floatPtr = moduleInstance.HEAPF32.subarray(buffer >> 2, (buffer >> 2) + typedArray.length);
        floatPtr[0] = 6.0;

        // Finally, call the function with "number" parameter type for the array (the pointer), and an extra length parameter
        // result = moduleInstance.ccall("addNums", null, ["number", "number"], [buffer, arrayDataToPass.length])
        result = ll.addNums(buffer, arrayDataToPass.length);
        console.log("made it through");
    } catch (e) {
        console.log("ERROR: " + e);
        error = e;
    } finally {
        // To avoid memory leaks we need to always clear out the allocated heap data
        // This needs to happen in the finally block, otherwise thrown errors will stop code execution before this happens
        moduleInstance._free(buffer);
    }

    console.log(result);
}
